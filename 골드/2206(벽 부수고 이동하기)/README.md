# <span style="color:orange; font-size:17pt; font-weight:bold">BOJ 2206번 벽 부수고 이동하기 문제 자바(java)  풀이</span>
- 난이도: 골드4
- [백준 2206번 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)
<br><br>

## [티스토리 주소](https://hoho325.tistory.com/)
<br><br>

# <span style="color: red; font-size:15pt">문제 정리</span>
1. NxM의 지도가 있다.
2. 0: 이동할 수 있는 곳
3. 1: 이동할 수 없는 벽
4. (1,1) -> (N, M) 위치까지 이동하려할 때 최단 경로로 이동하려 한다.
5. 최단 경로: 맵에서 가장 적은 개수의 칸을 지나는 경로 (시작 칸, 끝나는 칸 포함)
6. 이동하는 중에 벽을 한개 부수고 이동하는 것이 좀 더 짧아진다면 한 개 까지 부술 수 있다.
<br><br>

# <span style="color: red; font-size:15pt">첫번째 문제 접근</span>
우선 bfs로 탐색하면 되겠다고 생각하였습니다. 그래서 queue에 위치와 벽 부쉈는지 유무, 거리를 저장해갔습니다.  
방문하지 않았을 경우에만 queue에 넣고 계속탐색해 나갑니다.
1. 벽인데 이미 한 번 부순 경우 앞으로 못감 continue
2. 벽인데 부수지 않은 경우 부수고 간다.
3. 벽이 아닌 경우에는 그냥 그 길로 간다.
이렇게 3가지 경우를 나눠서 진행했습니다. 하지만 틀렸습니다가 나왔습니다.  
그 이유는 어떤 지점 (x,y)에 벽을 부수고 도달할 수도 있고 벽을 부수지 않고 도달할 수도 있기 때문입니다.  
즉 (x,y) 위치에 두번 방문할 수 있습니다. 그래서 이미 방문한 것으로 처리되 앞으로 나아가지 못하고 도착지에 도달하지 못할 수 있습니다.  
<br><br>

# <span style="color: red; font-size:15pt">첫번째 문제 접근 반례</span>
```
5 10
0000011000
1101011010
0000000010
1111111110
1111000000
```
<br><br>

# <span style="color: red; font-size:15pt">두번째 문제 접근</span>
위의 잘못된 풀이를 바로 잡기 위해 최소거리를 배열에 저장해가며 풀이했습니다.  
1. 벽인데 이미 부순 경우 앞으로 가지 못함
2. 벽인데 부수지 않은 경우 부수고 간다.
    부수고 가는데 현재까지 거리+1이 다음 위치에 저장된 최소거리보다 작거나 같은 경우에만 진행합니다.
    예를들어 현재 (5,5)에 저장된 최소 거리가 10이고 (5,6)으로 가려고 할때 1 더 이동해서 11이 됩니다.
    그런데 이때 (5,6)에 저장된 최소 거리가 9로 되어있을때 (5,5)에서 더 진행해도 이미 최소가 될 수 없으므로 가지 않습니다.
3. 벽이 아닌 경우 그냥 갑니다. 이 경우도 최소 거리를 비교하여 더 작거나 같은 경우에만 진행합니다.
4. 이렇게 하면 최종 visited[N-1][M-1]에는 (N-1, M-1)에 도달하기 까지의 최소거리가 저장되어 있습니다.
    만약 도달하지 못했다면 초기 값이 저장되 있을 것입니다.
이 방법을 이용해보았지만 이는 시간초과가 발생하였습니다.  
거리가 같은 경우에도 queue에 넣고 진행하기 때문에 중복이 많이 발생하는 것 같습니다.
<br><br>

# <span style="color: red; font-size:15pt">문제 풀이</span>
3차원 배열로 해서 4방향의 방문 여부를 계산도 해보았지만 실패였습니다.  
하지만 다시 생각해보면 위에서도 말했듯이 각 지점은 최대 2번 방문되게 됩니다.
- 벽을 부수고 (x,y)에 도달한 경우
- 벽을 부수지 않고 (x,y)에 도달한 경우

그래서 3차원 배열을 이용하여 벽을 부수고 도달한 경우와 그렇지 않은 경우의 방문 여부를 따로 보면 됩니다!!

1. 거리및 방문여부를 저장할 3차원 배열을 만듭니다.(value[N][M][2])
    [x][y][0]: 벽을 부수지 않고 방문했을때 거리
    [x][y][1]: 벽을 부수고 방문 했을때 거리
2. 초기 거리를 1로 초기화 합니다(시작 점도 포함하기 때문)
3. queue에서 하나를 뽑고 4가지 방향으로 탐색을 합니다.
4. 유효한 위치이고 방문하지 않았다면 탐색조건을 확인합니다.
    - 벽이 있지만 아직 뚫지 않은 경우
        벽을 부수지 않고 방문했을때의 거리 + 1로 벽을 부수고 방문했을때의 거리에 update합니다.
        그리고 queue에 넣을때 벽 부순 여부를 1로 바꿔줍니다.
    - 벽이 없고 방문하지 않은 경우
        이전까지 이동한 거리 + 1로 업데이트 합니다.
5. queue가 빌때까지 bfs를 계속 합니다.
6. min 값이 초기값이라면 끝에 도달하지 못한 경우이므로 -1을 출력, 그렇지 않은 경우 min 값을 출력합니다.
<br><Br>