# <span style="color:orange; font-size:17pt; font-weight:bold">BOJ 9997번 폰트 자바(java) 풀이</span>
- 난이도: 골드2
- [백준 9997번 폰트](https://www.acmicpc.net/problem/9997)
<br><br>

## [티스토리 주소](https://hoho325.tistory.com/)
<br><br>

# <span style="color: red; font-size:15pt">문제 정리</span>
1. 문장에는 알파벳 소문자만 포함되어 있다.
2. 테스트 문장에느 알파벳 소문자 26개가 모두 포함되어 있다.
3. 단어 N개가 포함되어 있는 사전을 하나 가지고 있다.
4. 테스트 문장은 사전에 포함된 단어만 이용해서 만들 수 있으며 각 단어는 한 번씩만 사용해야 한다.
5. 단어의 순서는 중요하지 않다.
6. 상근이가 만들 수 있는 테스트 문장의 개수를 구하는 프로그램을 작성하시오
<br><br>

# <span style="color: red; font-size:15pt">문제 접근</span>
1. 단순 조합
처음에는 조합으로 접근하였습니다.  
N개의 단어들에서 1개 뽑는 경우, 2개 뽑는 경우, N개 뽑는 경우 모두 완전탐색으로 따져보면 되기 때문입니다.  
그래서 visited 배열을 이용하여 단어를 선택해 나가고, 선택한 단어를 가지고 bit masking을 통해 모든 알파벳 비트가 1이 되었는지 검사하였습니다.
하지만 시간초과가 발생하였습니다.
<br>

2. 비트 마스킹된 알파벳 인자로 넘기며 백트래킹
이번에는 조합에 백트래킹 개념을 더하였습니다. 수를 선택하고 선택이 되었을때마다 문자를 모두 탐색하며 26개의 알파벳 비트가 모두 1로 되었는지 검사하였습니다.
하지만 이는 수를 하나씩 고를때마다 계속해서 다시 탐색했기 때문에 중복되는 계산이 있다는걸 알았습니다.  
그래서 매번 수를 선택할때마다 바로 bit masking을 한 후, 그 값을 이후 선택한 수 부터 바로 bis maksing 할 수 있도록 인자로 넘겨주었습니다.
하지만 이도 시간초과...
<br>

3. 단어의 알파벳 bit masking 미리 구하기 (Main2.java)
시간을 어떻게 줄일 수 있을까?? 무엇이 중복되었을까??? 보다가 찾았습니다.  
매번 단어를 선택할 때마다 그 단어의 bit masking을 계속해서 다시 구했습니다.  
그래서 이를 입력받을때 문자를 저장하는것이 아니라 bit masking 값을 저장해두어 처음 딱 한번만 구하도록 하였습니다.  
이렇게 구한 값을 수가 선택되었을때 바로 배열에서 꺼내 bit 연산을 할 수 있었습니다.
이렇게 통과하였습니다.
- 시간: 1576ms
- 메모리: 12920kb

4. 최적화 (Main.java)
다른 사람들은 얼마나 빨리 풀었을까 기록을 보니 저보다 약 7배나 빨랐습니다.  
무엇이 이렇게 많이 차이가 났을까?? 하고 보았습니다.
그것은 바로 트리 형태로 뻗어나가는 것이었습니다.(비트 마스킹 개념)
첫 번째 단어를 선택하냐 안하냐에 따라 두가지 길로 나뉩니다.  
첫 번째 단어를 선택했다면 그 다음은 두 번째 단어를 선택하냐 안하냐로 또 길이 나뉩니다.  
첫 번째 단어를 선택안한 상태에서도 두 번째 단어를 선택하냐 안하냐로 길이 또 나뉩니다.  
이렇게 계속 길을 나눠가는 개념입니다.
<br><br>

# <span style="color: red; font-size:15pt">문제 풀이(Main.java)</span>
1. 단어 수 N개 만큼의 배열을 만듭니다.
2. 단어를 입력 받아서 단어의 문자마다 확인합니다.
    문자에서 'a'를 뺍니다. 즉 아스키 코드 값을 빼서 숫자로 변환합니다. 예를들어 a는 0, b는 1이 됩니다.
    그리고 이를 그 수 만큼 오른쪽으로 bit shift 합니다.
    예를들어 abd라는 단어였다면 bit shift를 통해 이 단어는 1011라는 bit로 표현할 수 있습니다.
    첫 번째 bit가 1이라는 것은 a라는 문자가 있고, 세 번째 bit가 0이라는 것은 c라는 문자가 없다는 뜻입니다.
3. dfs 탐색을 합니다.
4. dfs 탐색은 선택하는 경우에 선택한 문자의 bit 값을 OR 연산하여 어떤 알파벳이 있는지 누적해갑니다.
5. 선택하지 않는 경우에는 인자로 받은 alpha 값 그대로 넘겨줍니다.
6. 깊이 N-1에 도달 한 후, alpha 값이 모든 26개의 알파벳을 나타내는 비트( (1 << 26) - 1)가 1인지 확인합니다.
그렇다면 ans를 증가 시키고 그렇지 않다면 트리의 위로 올라가서 다른 경우를 탐색합니다.
<br><Br>