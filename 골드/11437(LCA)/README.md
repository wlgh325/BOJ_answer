# BOJ 11437번 LCA 자바(java)  풀이
- 랭크 : 골드3
- 백준 온라인 저지(BOJ) 11437번 LCA 문제 자바 풀이
- [백준 11437번 LCA](https://www.acmicpc.net/problem/11473)

## [티스토리 주소](https://hoho325.tistory.com/)

# 문제정리
1. 1~N번으로 번호가 매겨진 정점들이 주어진다.
2. 루트는 1번이다.
3. 가장 가까운 공통 조상을 알고 싶은 m개의 쌍이 주어진다.
4. n-1개의 트리 상에서 두 정점의 연결 정보가 주어진다. 이때 A B라고 주어질때 A가 부모라는 보장이 없다.

# 문제풀이
이 문제는 LCA(Lowest Common Ancestor)문제 입니다.  
**LCA**를 검색하면 정리된 많은 자료들을 볼 수 있습니다.  
6과 11의 LCA을 구하는 것을 예로 들겠습니다.  
1. 부모 노드가 정해져있지 않기 때문에 모든 노드의 dfs를 돌면서 depth를 구합니다.
    이때 depth가 0인 것은 depth를 아직 구하지 않은 노드이기 때문에 dfs를 물고 들어가서 depth를 update 시켜줍니다.
    루트 노드인 **1부터 출발**합니다. 1과 연결된 점으로 우선 2가 있습니다.
    그러면 2에는 **4,6,5**가 있습니다. 재귀로 들어왔기 때문에 4는 depth가 증가한 상태입니다.
    4와 연결된 점에는 **2,9**가 있는데 2는 이미 depth를 구했고 9를 from값으로 들어갑니다.
    이제 더 이상 9와 연결된 점이 없습니다.(4는 이미 depth가 update됨)
    그러면 **4가 from인 context로 돌아와서** 이제 9의 부모가 4가 됨을 알 수 있습니다.
    4에 대해서 끝났고 **2가 from인 context로 돌아와서** 6을 탐색하고 6의 부모는 2임을 update할 수 있습니다.
    이와 같은 방식으로 depth를 가지고 부모와 자식간의 관계를 구할 수 있습니다.
2. 이제 둘 중 depth가 더 작은 것에 기준을 맞춰서 **depth를 같게** 해줍니다.
    11의 depth가 더 크기 때문에 6에 맞춰서 올려줍니다. 즉 11은 5로 바뀝니다.
3. 그리고 depth를 하나씩 감소시키면서(위로 올리면서) **같은 값이 나올때까지 반복**합니다.
    6과 11에서 parent를 이용해 하나씩 올리면 둘다 2가 나오면서 같게 되고 이가 LCA가 됩니다.