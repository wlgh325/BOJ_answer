# BOJ 1966번 프린터 큐 문제 자바(java)  풀이
- 난이도: 실버3
- 풀이 시간: 25분
- [백준 1966번 프린터 큐](https://www.acmicpc.net/problem/1966)

## [티스토리 주소](https://hoho325.tistory.com/)

# 문제정리
1. 프린터는 먼저 요청된 것을 처리한다. 즉 Queue의 FIFO에 따라 인쇄한다.
2. 새로 개발한 프린터는 queue의 가장 앞에 있는 문서의 중요도를 확인한다.
3. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 queue의 가장 뒤에 배치한다. 그렇지 않다면 인쇄!


# 문제 접근
이 문제는 전에 [프로그래머스의 프린터 큐](https://hoho325.tistory.com/48?category=819057) 문제와 같습니다.  
그래서 어떻게 풀었는지 대충 생각이 낫지만 더 빠르고 간단하게 풀고 싶어서 고민을 했습니다.  
1. 매번 queue의 모든 중요도를 탐색하며 더 높은 중요도가 있는지 체크한다
    이 방법이 가장 naive하다고 볼 수 있습니다. 이 방법으로 프로그래머스에서 통과하였습니다.
    하지만 이는 최악의 경우 queue에 담긴 N개를 계속 탐색해야 하고
    탐색하기 위해 list로 변환하는 과정이 필요해 메모리도 추가로 발생합니다.
2. 중요도를 내림차순 정렬해놓고 현 요청 중 가장 높은 중요도를 업데이트 한다.
    이번에는 이 방법으로 해결하였습니다.

# 문제풀이
2번 tc를 예로 들겠습니다. 중요도를 내림차순으로 정렬하면 4321이 됩니다.  
즉 중요도 4가 현재 가장 큰 중요도입니다.  
1. 1부터 꺼냅니다. 현재 가장 큰 중요도 4보다 작기 때문에 다시 넣습니다.
2. 2와 3도 마찬가지입니다.
3. 4를 꺼냅니다. 현재 가장 큰 중요도인 4이기 때문에 다시 넣지 않고 출력을 실행합니다. => 첫번째로 인쇄되는 3번째 문서(index 0부터 시작)
4. 이제 중요도 4를 갖는 요청은 실행되었기 때문에 다음으로 높은 3이 현재 가장 큰 중요도를 갖습니다.
5. 다음 다시 1과2를 꺼냈다가 다시 넣습니다.
6. 이제 3을 꺼냅니다. 현재 가장 높은 중요도인 3이므로 실행하고 다시 넣지 않습니다. -> 두 번째로 인쇄되는 2번째 문서
7. 이제 현재 가장 높은 중요도가 2로 갱신되었습니다.
8. 1을 꺼냈다가 다시 넣고 2가 현재 가장 높은 중요도이므로 실행하고 다시 넣지 않습니다 -> 세 번째로 인쇄되는 1번째 문서
9. 중요도가 1로 갱신되고 1을 마지막으로 출력합니다 => 마지막으로 출력되는 0번째 문서
3번째 tc도 마찬가지입니다. 같은 중요도를 가지는 요청이 있어도 상관없습니다. (차례대로 출력하기 때문)

# 중요도 정렬 (Comparator 구현)
중요도를 ArrayList에 담고 Collections.sort()를 이용해 내림차순 정렬하였습니다.
Comparater을 직접 구현하였습니다.
```java
    // 중요도를 내림차순 정렬
    Collections.sort(list, new Comparator<Integer>() {
        @Override
        public int compare(Integer a, Integer b){
            if(a < b)
                return 1;
            else if(a>b)
                return -1;
            return 0;
        }
    });
    내림 차순으로 정렬하기 위해서 오름차순의 기본 반환값과 반대로 하였습니다.
```

- 내림차순
```
compare 함수의 두 번째 인자의 값이 크다면 1
작다면 1
같다면 0을 리턴한다
```

- 오름차순
```
내림차순과 반대이다
Collections.sort(list)를 하게되면 기본적으로 오름차순 정렬입니다.
compare 함수의 두 번째 인자의 값이 크다면 -1
작다면 1
같다면 -1을 리턴합니다.
```